{"ast":null,"code":"/**\n * FingerprintJS Pro SPA v0.6.0 - Copyright (c) FingerprintJS, Inc, 2022 (https://fingerprint.com)\n * Licensed under the MIT (http://www.opensource.org/licenses/mit-license.php) license.\n */\n\nimport { __awaiter } from 'tslib';\nimport * as FingerprintJS from '@fingerprintjs/fingerprintjs-pro';\nconst CACHE_KEY_PREFIX = '@fpjs@client@';\nconst MAX_CACHE_LIFE = 60 * 60 * 24; // 24 hours\nconst DEFAULT_CACHE_LIFE = 60 * 60; // 1 hour\nconst DEFAULT_NOW_PROVIDER = () => Date.now();\nclass CacheKey {\n  constructor(options) {\n    var _a;\n    this.tag = options.tag || null;\n    this.linkedId = options.linkedId || null;\n    this.extendedResult = (_a = options.extendedResult) !== null && _a !== void 0 ? _a : false;\n  }\n  /**\n   * Converts this `CacheKey` instance into a string for use in a cache\n   * @returns A string representation of the key\n   */\n  toKey() {\n    return `${JSON.stringify(this.tag)}__${JSON.stringify(this.linkedId)}__${this.extendedResult}`;\n  }\n}\nfunction getKeyWithPrefix(key, prefix) {\n  return `${prefix}__${key}`;\n}\nfunction removePrefixFromKey(key, prefix) {\n  return key.replace(`${prefix}__`, '');\n}\n\n/**\n * Implementation of caching that uses local storage\n * */\nclass LocalStorageCache {\n  constructor() {\n    let prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : CACHE_KEY_PREFIX;\n    this.prefix = prefix;\n  }\n  set(key, entry) {\n    window.localStorage.setItem(getKeyWithPrefix(key, this.prefix), JSON.stringify(entry));\n  }\n  get(key) {\n    const json = window.localStorage.getItem(getKeyWithPrefix(key, this.prefix));\n    if (!json) {\n      return;\n    }\n    try {\n      return JSON.parse(json);\n    } catch (e) {\n      return;\n    }\n  }\n  remove(key) {\n    window.localStorage.removeItem(getKeyWithPrefix(key, this.prefix));\n  }\n  allKeys() {\n    return Object.keys(window.localStorage).filter(key => key.startsWith(this.prefix)).map(key => removePrefixFromKey(key, this.prefix));\n  }\n}\n\n/**\n * Implementation of caching that uses session storage\n * */\nclass SessionStorageCache {\n  constructor() {\n    let prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : CACHE_KEY_PREFIX;\n    this.prefix = prefix;\n  }\n  /**\n   * It takes a key and an entry, and sets the entry in the session storage with the key\n   * @param {string} key - The key to store the entry under.\n   * @param {Cacheable} entry - The value to be stored in the cache.\n   */\n  set(key, entry) {\n    window.sessionStorage.setItem(getKeyWithPrefix(key, this.prefix), JSON.stringify(entry));\n  }\n  /**\n   * It gets the value of the key from the session storage, parses it as JSON, and returns it\n   * @param {string} key - The key to store the data under.\n   * @returns The value of the key in the sessionStorage.\n   */\n  get(key) {\n    const json = window.sessionStorage.getItem(getKeyWithPrefix(key, this.prefix));\n    if (!json) {\n      return;\n    }\n    try {\n      return JSON.parse(json);\n    } catch (e) {\n      return;\n    }\n  }\n  /**\n   * It removes the item from session storage with the given key\n   * @param {string} key - The key to store the value under.\n   */\n  remove(key) {\n    window.sessionStorage.removeItem(getKeyWithPrefix(key, this.prefix));\n  }\n  /**\n   * It returns an array of all the keys in the session storage that start with the prefix\n   * @returns An array of all the keys in the sessionStorage that start with the prefix.\n   */\n  allKeys() {\n    return Object.keys(window.sessionStorage).filter(key => key.startsWith(this.prefix)).map(key => removePrefixFromKey(key, this.prefix));\n  }\n}\n\n/**\n * Wraps a cache implementation and adds expiration logic\n * */\nclass CacheManager {\n  constructor(cache) {\n    let cacheTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_CACHE_LIFE;\n    let nowProvider = arguments.length > 2 ? arguments[2] : undefined;\n    this.cache = cache;\n    this.cacheTime = cacheTime;\n    this.nowProvider = nowProvider || DEFAULT_NOW_PROVIDER;\n  }\n  /**\n   * It gets a cache entry from the cache, and if it's expired, it removes it from the cache\n   * @param cacheKey - CacheKey<TExtended>\n   * @returns A promise that resolves to a cache entry or undefined.\n   */\n  get(cacheKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const wrappedEntry = yield this.cache.get(cacheKey.toKey());\n      if (!wrappedEntry) {\n        return;\n      }\n      const now = yield this.nowProvider();\n      const nowSeconds = Math.floor(now / 1000);\n      if (wrappedEntry.expiresAt < nowSeconds) {\n        yield this.cache.remove(cacheKey.toKey());\n        return;\n      }\n      return wrappedEntry.body;\n    });\n  }\n  /**\n   * It takes a cache key and a cache entry, wraps the cache entry, and then sets the wrapped cache entry in the cache\n   * @param cacheKey - CacheKey<TExtended>\n   * @param {CacheEntry} entry - The cache entry to be stored.\n   */\n  set(cacheKey, entry) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const wrappedEntry = yield this.wrapCacheEntry(entry);\n      yield this.cache.set(cacheKey.toKey(), wrappedEntry);\n    });\n  }\n  /**\n   * It gets all the keys in the cache, and then removes them all\n   */\n  clearCache() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const keys = yield this.cache.allKeys();\n      yield Promise.all(keys.map(key => this.cache.remove(key)));\n    });\n  }\n  wrapCacheEntry(entry) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const now = yield this.nowProvider();\n      const expiresInTime = Math.floor(now / 1000) + this.cacheTime;\n      return {\n        body: entry,\n        expiresAt: expiresInTime\n      };\n    });\n  }\n}\n\n/**\n * Implementation of caching that uses in-memory storage\n * */\nclass InMemoryCache {\n  constructor() {\n    this.enclosedCache = function () {\n      const cache = {};\n      return {\n        set(key, entry) {\n          cache[key] = entry;\n        },\n        get(key) {\n          const cacheEntry = cache[key];\n          if (!cacheEntry) {\n            return;\n          }\n          return cacheEntry;\n        },\n        remove(key) {\n          delete cache[key];\n        },\n        allKeys() {\n          return Object.keys(cache);\n        }\n      };\n    }();\n  }\n}\n\n/**\n * Implementation of stub cache that is used when cache is disabled by user\n * */\nclass CacheStub {\n  set() {}\n  get() {\n    return undefined;\n  }\n  remove() {}\n  allKeys() {\n    return [];\n  }\n}\nvar CacheLocation;\n(function (CacheLocation) {\n  CacheLocation[\"Memory\"] = \"memory\";\n  CacheLocation[\"LocalStorage\"] = \"localstorage\";\n  CacheLocation[\"SessionStorage\"] = \"sessionstorage\";\n  CacheLocation[\"NoCache\"] = \"nocache\";\n})(CacheLocation || (CacheLocation = {}));\nvar version = \"0.6.0\";\nconst cacheLocationBuilders = {\n  [CacheLocation.Memory]: () => new InMemoryCache().enclosedCache,\n  [CacheLocation.LocalStorage]: prefix => new LocalStorageCache(prefix),\n  [CacheLocation.SessionStorage]: prefix => new SessionStorageCache(prefix),\n  [CacheLocation.NoCache]: () => new CacheStub()\n};\nconst cacheFactory = location => {\n  return cacheLocationBuilders[location];\n};\n/**\n * FingerprintJS SDK for Single Page Applications\n */\nclass FpjsClient {\n  constructor(options) {\n    var _a;\n    this.options = options;\n    this.inFlightRequests = new Map();\n    this.agentPromise = null;\n    this.agent = {\n      get: () => {\n        throw new Error(\"FPJSAgent hasn't loaded yet. Make sure to call the init() method first.\");\n      }\n    };\n    this.loadOptions = Object.assign(Object.assign({}, options.loadOptions), {\n      integrationInfo: [...(options.loadOptions.integrationInfo || []), `fingerprintjs-pro-spa/${version}`]\n    });\n    if (options.cache && options.cacheLocation) {\n      console.warn('Both `cache` and `cacheLocation` options have been specified in the FpjsClient configuration; ignoring `cacheLocation` and using `cache`.');\n    }\n    let cache;\n    if (options.cache) {\n      cache = options.cache;\n    } else {\n      this.cacheLocation = options.cacheLocation || CacheLocation.SessionStorage;\n      if (!cacheFactory(this.cacheLocation)) {\n        throw new Error(`Invalid cache location \"${this.cacheLocation}\"`);\n      }\n      cache = cacheFactory(this.cacheLocation)(options.cachePrefix);\n    }\n    if (options.cacheTimeInSeconds && options.cacheTimeInSeconds > MAX_CACHE_LIFE) {\n      throw new Error(`Cache time cannot exceed 86400 seconds (24 hours)`);\n    }\n    const cacheTime = (_a = options.cacheTimeInSeconds) !== null && _a !== void 0 ? _a : DEFAULT_CACHE_LIFE;\n    this.cacheManager = new CacheManager(cache, cacheTime);\n  }\n  /**\n   * Loads FPJS JS agent with certain settings and stores the instance in memory\n   * [https://dev.fingerprint.com/docs/js-agent#agent-initialization]\n   */\n  init() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.agentPromise) {\n        this.agentPromise = FingerprintJS.load(this.loadOptions).then(agent => {\n          this.agent = agent;\n          return agent;\n        }).catch(error => {\n          this.agentPromise = null;\n          throw error;\n        });\n      }\n      return this.agentPromise;\n    });\n  }\n  /**\n   * Returns visitor identification data based on the request options\n   * [https://dev.fingerprint.com/docs/js-agent#visitor-identification]\n   *\n   * @param options\n   * @param ignoreCache if set to true a request to the API will be made even if the data is present in cache\n   */\n  getVisitorData() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let ignoreCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return __awaiter(this, void 0, void 0, function* () {\n      const cacheKey = FpjsClient.makeCacheKey(options);\n      const key = cacheKey.toKey();\n      if (!this.inFlightRequests.has(key)) {\n        const promise = this._identify(options, ignoreCache).finally(() => {\n          this.inFlightRequests.delete(key);\n        });\n        this.inFlightRequests.set(key, promise);\n      }\n      return yield this.inFlightRequests.get(key);\n    });\n  }\n  /**\n   * Clears visitor data from cache regardless of the cache implementation\n   */\n  clearCache() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.cacheManager.clearCache();\n    });\n  }\n  /**\n   * Makes a CacheKey object from GetOptions\n   */\n  static makeCacheKey(options) {\n    return new CacheKey(options);\n  }\n  _identify(options) {\n    let ignoreCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return __awaiter(this, void 0, void 0, function* () {\n      const key = FpjsClient.makeCacheKey(options);\n      if (!ignoreCache) {\n        const cacheResult = yield this.cacheManager.get(key);\n        if (cacheResult) {\n          return cacheResult;\n        }\n      }\n      const agentResult = yield this.agent.get(options);\n      yield this.cacheManager.set(key, agentResult);\n      return agentResult;\n    });\n  }\n}\nexport { CacheLocation, CacheStub, FpjsClient, InMemoryCache, LocalStorageCache, SessionStorageCache };","map":{"version":3,"names":["__awaiter","FingerprintJS","CACHE_KEY_PREFIX","MAX_CACHE_LIFE","DEFAULT_CACHE_LIFE","DEFAULT_NOW_PROVIDER","Date","now","CacheKey","constructor","options","_a","tag","linkedId","extendedResult","toKey","JSON","stringify","getKeyWithPrefix","key","prefix","removePrefixFromKey","replace","LocalStorageCache","set","entry","window","localStorage","setItem","get","json","getItem","parse","e","remove","removeItem","allKeys","Object","keys","filter","startsWith","map","SessionStorageCache","sessionStorage","CacheManager","cache","cacheTime","nowProvider","cacheKey","wrappedEntry","nowSeconds","Math","floor","expiresAt","body","wrapCacheEntry","clearCache","Promise","all","expiresInTime","InMemoryCache","enclosedCache","cacheEntry","CacheStub","undefined","CacheLocation","version","cacheLocationBuilders","Memory","LocalStorage","SessionStorage","NoCache","cacheFactory","location","FpjsClient","inFlightRequests","Map","agentPromise","agent","Error","loadOptions","assign","integrationInfo","cacheLocation","console","warn","cachePrefix","cacheTimeInSeconds","cacheManager","init","load","then","catch","error","getVisitorData","ignoreCache","makeCacheKey","has","promise","_identify","finally","delete","cacheResult","agentResult"],"sources":["/Users/sg17lpt/Developer/simple-camera-app/node_modules/@fingerprintjs/fingerprintjs-pro-spa/dist/fp-pro-spa.esm.js"],"sourcesContent":["/**\n * FingerprintJS Pro SPA v0.6.0 - Copyright (c) FingerprintJS, Inc, 2022 (https://fingerprint.com)\n * Licensed under the MIT (http://www.opensource.org/licenses/mit-license.php) license.\n */\n\nimport { __awaiter } from 'tslib';\nimport * as FingerprintJS from '@fingerprintjs/fingerprintjs-pro';\n\nconst CACHE_KEY_PREFIX = '@fpjs@client@';\nconst MAX_CACHE_LIFE = 60 * 60 * 24; // 24 hours\nconst DEFAULT_CACHE_LIFE = 60 * 60; // 1 hour\nconst DEFAULT_NOW_PROVIDER = () => Date.now();\nclass CacheKey {\n    constructor(options) {\n        var _a;\n        this.tag = options.tag || null;\n        this.linkedId = options.linkedId || null;\n        this.extendedResult = (_a = options.extendedResult) !== null && _a !== void 0 ? _a : false;\n    }\n    /**\n     * Converts this `CacheKey` instance into a string for use in a cache\n     * @returns A string representation of the key\n     */\n    toKey() {\n        return `${JSON.stringify(this.tag)}__${JSON.stringify(this.linkedId)}__${this.extendedResult}`;\n    }\n}\nfunction getKeyWithPrefix(key, prefix) {\n    return `${prefix}__${key}`;\n}\nfunction removePrefixFromKey(key, prefix) {\n    return key.replace(`${prefix}__`, '');\n}\n\n/**\n * Implementation of caching that uses local storage\n * */\nclass LocalStorageCache {\n    constructor(prefix = CACHE_KEY_PREFIX) {\n        this.prefix = prefix;\n    }\n    set(key, entry) {\n        window.localStorage.setItem(getKeyWithPrefix(key, this.prefix), JSON.stringify(entry));\n    }\n    get(key) {\n        const json = window.localStorage.getItem(getKeyWithPrefix(key, this.prefix));\n        if (!json) {\n            return;\n        }\n        try {\n            return JSON.parse(json);\n        }\n        catch (e) {\n            return;\n        }\n    }\n    remove(key) {\n        window.localStorage.removeItem(getKeyWithPrefix(key, this.prefix));\n    }\n    allKeys() {\n        return Object.keys(window.localStorage)\n            .filter((key) => key.startsWith(this.prefix))\n            .map((key) => removePrefixFromKey(key, this.prefix));\n    }\n}\n\n/**\n * Implementation of caching that uses session storage\n * */\nclass SessionStorageCache {\n    constructor(prefix = CACHE_KEY_PREFIX) {\n        this.prefix = prefix;\n    }\n    /**\n     * It takes a key and an entry, and sets the entry in the session storage with the key\n     * @param {string} key - The key to store the entry under.\n     * @param {Cacheable} entry - The value to be stored in the cache.\n     */\n    set(key, entry) {\n        window.sessionStorage.setItem(getKeyWithPrefix(key, this.prefix), JSON.stringify(entry));\n    }\n    /**\n     * It gets the value of the key from the session storage, parses it as JSON, and returns it\n     * @param {string} key - The key to store the data under.\n     * @returns The value of the key in the sessionStorage.\n     */\n    get(key) {\n        const json = window.sessionStorage.getItem(getKeyWithPrefix(key, this.prefix));\n        if (!json) {\n            return;\n        }\n        try {\n            return JSON.parse(json);\n        }\n        catch (e) {\n            return;\n        }\n    }\n    /**\n     * It removes the item from session storage with the given key\n     * @param {string} key - The key to store the value under.\n     */\n    remove(key) {\n        window.sessionStorage.removeItem(getKeyWithPrefix(key, this.prefix));\n    }\n    /**\n     * It returns an array of all the keys in the session storage that start with the prefix\n     * @returns An array of all the keys in the sessionStorage that start with the prefix.\n     */\n    allKeys() {\n        return Object.keys(window.sessionStorage)\n            .filter((key) => key.startsWith(this.prefix))\n            .map((key) => removePrefixFromKey(key, this.prefix));\n    }\n}\n\n/**\n * Wraps a cache implementation and adds expiration logic\n * */\nclass CacheManager {\n    constructor(cache, cacheTime = DEFAULT_CACHE_LIFE, nowProvider) {\n        this.cache = cache;\n        this.cacheTime = cacheTime;\n        this.nowProvider = nowProvider || DEFAULT_NOW_PROVIDER;\n    }\n    /**\n     * It gets a cache entry from the cache, and if it's expired, it removes it from the cache\n     * @param cacheKey - CacheKey<TExtended>\n     * @returns A promise that resolves to a cache entry or undefined.\n     */\n    get(cacheKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const wrappedEntry = yield this.cache.get(cacheKey.toKey());\n            if (!wrappedEntry) {\n                return;\n            }\n            const now = yield this.nowProvider();\n            const nowSeconds = Math.floor(now / 1000);\n            if (wrappedEntry.expiresAt < nowSeconds) {\n                yield this.cache.remove(cacheKey.toKey());\n                return;\n            }\n            return wrappedEntry.body;\n        });\n    }\n    /**\n     * It takes a cache key and a cache entry, wraps the cache entry, and then sets the wrapped cache entry in the cache\n     * @param cacheKey - CacheKey<TExtended>\n     * @param {CacheEntry} entry - The cache entry to be stored.\n     */\n    set(cacheKey, entry) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const wrappedEntry = yield this.wrapCacheEntry(entry);\n            yield this.cache.set(cacheKey.toKey(), wrappedEntry);\n        });\n    }\n    /**\n     * It gets all the keys in the cache, and then removes them all\n     */\n    clearCache() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const keys = yield this.cache.allKeys();\n            yield Promise.all(keys.map((key) => this.cache.remove(key)));\n        });\n    }\n    wrapCacheEntry(entry) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const now = yield this.nowProvider();\n            const expiresInTime = Math.floor(now / 1000) + this.cacheTime;\n            return {\n                body: entry,\n                expiresAt: expiresInTime,\n            };\n        });\n    }\n}\n\n/**\n * Implementation of caching that uses in-memory storage\n * */\nclass InMemoryCache {\n    constructor() {\n        this.enclosedCache = (function () {\n            const cache = {};\n            return {\n                set(key, entry) {\n                    cache[key] = entry;\n                },\n                get(key) {\n                    const cacheEntry = cache[key];\n                    if (!cacheEntry) {\n                        return;\n                    }\n                    return cacheEntry;\n                },\n                remove(key) {\n                    delete cache[key];\n                },\n                allKeys() {\n                    return Object.keys(cache);\n                },\n            };\n        })();\n    }\n}\n\n/**\n * Implementation of stub cache that is used when cache is disabled by user\n * */\nclass CacheStub {\n    set() { }\n    get() {\n        return undefined;\n    }\n    remove() { }\n    allKeys() {\n        return [];\n    }\n}\n\nvar CacheLocation;\n(function (CacheLocation) {\n    CacheLocation[\"Memory\"] = \"memory\";\n    CacheLocation[\"LocalStorage\"] = \"localstorage\";\n    CacheLocation[\"SessionStorage\"] = \"sessionstorage\";\n    CacheLocation[\"NoCache\"] = \"nocache\";\n})(CacheLocation || (CacheLocation = {}));\n\nvar version = \"0.6.0\";\n\nconst cacheLocationBuilders = {\n    [CacheLocation.Memory]: () => new InMemoryCache().enclosedCache,\n    [CacheLocation.LocalStorage]: (prefix) => new LocalStorageCache(prefix),\n    [CacheLocation.SessionStorage]: (prefix) => new SessionStorageCache(prefix),\n    [CacheLocation.NoCache]: () => new CacheStub(),\n};\nconst cacheFactory = (location) => {\n    return cacheLocationBuilders[location];\n};\n/**\n * FingerprintJS SDK for Single Page Applications\n */\nclass FpjsClient {\n    constructor(options) {\n        var _a;\n        this.options = options;\n        this.inFlightRequests = new Map();\n        this.agentPromise = null;\n        this.agent = {\n            get: () => {\n                throw new Error(\"FPJSAgent hasn't loaded yet. Make sure to call the init() method first.\");\n            },\n        };\n        this.loadOptions = Object.assign(Object.assign({}, options.loadOptions), { integrationInfo: [...(options.loadOptions.integrationInfo || []), `fingerprintjs-pro-spa/${version}`] });\n        if (options.cache && options.cacheLocation) {\n            console.warn('Both `cache` and `cacheLocation` options have been specified in the FpjsClient configuration; ignoring `cacheLocation` and using `cache`.');\n        }\n        let cache;\n        if (options.cache) {\n            cache = options.cache;\n        }\n        else {\n            this.cacheLocation = options.cacheLocation || CacheLocation.SessionStorage;\n            if (!cacheFactory(this.cacheLocation)) {\n                throw new Error(`Invalid cache location \"${this.cacheLocation}\"`);\n            }\n            cache = cacheFactory(this.cacheLocation)(options.cachePrefix);\n        }\n        if (options.cacheTimeInSeconds && options.cacheTimeInSeconds > MAX_CACHE_LIFE) {\n            throw new Error(`Cache time cannot exceed 86400 seconds (24 hours)`);\n        }\n        const cacheTime = (_a = options.cacheTimeInSeconds) !== null && _a !== void 0 ? _a : DEFAULT_CACHE_LIFE;\n        this.cacheManager = new CacheManager(cache, cacheTime);\n    }\n    /**\n     * Loads FPJS JS agent with certain settings and stores the instance in memory\n     * [https://dev.fingerprint.com/docs/js-agent#agent-initialization]\n     */\n    init() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.agentPromise) {\n                this.agentPromise = FingerprintJS.load(this.loadOptions)\n                    .then((agent) => {\n                    this.agent = agent;\n                    return agent;\n                })\n                    .catch((error) => {\n                    this.agentPromise = null;\n                    throw error;\n                });\n            }\n            return this.agentPromise;\n        });\n    }\n    /**\n     * Returns visitor identification data based on the request options\n     * [https://dev.fingerprint.com/docs/js-agent#visitor-identification]\n     *\n     * @param options\n     * @param ignoreCache if set to true a request to the API will be made even if the data is present in cache\n     */\n    getVisitorData(options = {}, ignoreCache = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const cacheKey = FpjsClient.makeCacheKey(options);\n            const key = cacheKey.toKey();\n            if (!this.inFlightRequests.has(key)) {\n                const promise = this._identify(options, ignoreCache).finally(() => {\n                    this.inFlightRequests.delete(key);\n                });\n                this.inFlightRequests.set(key, promise);\n            }\n            return (yield this.inFlightRequests.get(key));\n        });\n    }\n    /**\n     * Clears visitor data from cache regardless of the cache implementation\n     */\n    clearCache() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.cacheManager.clearCache();\n        });\n    }\n    /**\n     * Makes a CacheKey object from GetOptions\n     */\n    static makeCacheKey(options) {\n        return new CacheKey(options);\n    }\n    _identify(options, ignoreCache = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const key = FpjsClient.makeCacheKey(options);\n            if (!ignoreCache) {\n                const cacheResult = yield this.cacheManager.get(key);\n                if (cacheResult) {\n                    return cacheResult;\n                }\n            }\n            const agentResult = yield this.agent.get(options);\n            yield this.cacheManager.set(key, agentResult);\n            return agentResult;\n        });\n    }\n}\n\nexport { CacheLocation, CacheStub, FpjsClient, InMemoryCache, LocalStorageCache, SessionStorageCache };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}